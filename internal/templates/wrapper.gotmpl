// Code generated by github.com/pm1381/sirish. DO NOT EDIT.
// Version {{ .Version }}

package {{ .Interface.Package }}

{{- $iface := .Interface -}}
{{- $typeBaseString := printf "%sWrapper" .TypeName -}}
{{- $wrapperName := printf "%sImpl" $typeBaseString -}}
{{- $needTx := .CreateTx -}}

{{- /* IMPORTS SECTION */}}
{{- if .Imports }}
import (
    {{ range $path, $alias := .Imports }}
        {{- if eq $alias "" }}
    "{{ $path }}"
        {{- else }}
    {{ $alias }} "{{ $path }}"
        {{- end }}
    {{- end }}
)
{{- end }}

{{/* ---------- WRAPPER TYPE ---------- */}}
type {{ $wrapperName }} struct {
    // TODO: Visitor supports generics. add generics to template
    name          string
    wrapped       {{ $iface.Name }}
    interfaceName string
    tagType       string
}

{{/* ---------- CONSTRUCTOR ---------- */}}
func New{{$wrapperName}}(
    name string,
    wrapped {{$iface.Name}},
    tagType string,
) *{{$wrapperName}} {

    return &{{$wrapperName}}{
        name:           name,
        tagType:        tagType,
        interfaceName:  "{{ .Interface.Name }}",
        wrapped:        wrapped,
    }
}

{{/* ---------- METHODS ---------- */}}
{{- range $m := $iface.Methods }}

func (w *{{ $wrapperName }}) {{$m.Name}}({{$m.ParamsOverallNames}}) {{- if $m.Results }} (
    {{- if $m.HasNamedResult }}{{$m.ResultOverallNames}}{{- else}}{{$m.ResultTypesNames}}{{- end}}){{ end }} {

    {{- if $m.HasCtx }}
    var {{$m.SpanName}} *apm.Span
    {{$m.SpanName}}, {{$m.CtxName}} = apm.StartSpan({{$m.CtxName}}, "{{$m.SpecialName}}", w.tagType)
    {{$m.SpanName}}.Context.SetLabel("label", w.name)
    defer {{$m.SpanName}}.End()

    {{- else }}
        {{- if $needTx }}
    var {{$m.SpanName}} *apm.Span
    tx := apm.DefaultTracer().StartTransaction("{{$m.SpecialName}}", w.tagType)
    defer tx.End()
    {{$m.SpanName}}, _ = apm.StartSpan(apm.ContextWithTransaction(context.Background(), tx), "{{printf "%sSpan" $m.Name}}", w.tagType)
    {{$m.SpanName}}.Context.SetLabel("label", w.name)
    defer {{$m.SpanName}}.End()
        {{- end }}

    {{- end}}

    {{- /* Call underlying method */}}
    {{- if $m.Results }}
        {{- if $m.HasNamedResult }}
    {{$m.ResultNames}} = w.wrapped.{{$m.Name}}({{$m.ParamsNames}})
        {{- else }}
    {{$m.ResultNames}} := w.wrapped.{{$m.Name}}({{$m.ParamsNames}})
        {{- end}}
    {{- else}}
    w.wrapped.{{$m.Name}}({{$m.ParamsNames}})
    return
    {{- end}}
    {{- if $m.Results}}
        {{- if or $m.HasCtx $needTx}}
            {{- if ne $m.ErrorName "" }}
    if {{$m.ErrorName}} != nil {
                {{- if $m.HasCtx}}
    apm.CaptureError({{$m.CtxName}}, {{$m.ErrorName}}).SetSpan({{$m.SpanName}})
                {{- end}}
    {{$m.SpanName}}.Outcome = "failure"
    } else {
        {{$m.SpanName}}.Outcome = "success"
    }
            {{- end}}
        {{- end}}
    return {{$m.ResultNames}}
    {{- end}}
}
{{ end }}
